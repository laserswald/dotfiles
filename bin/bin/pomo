#! /usr/bin/env chibi-scheme
;;;; vim: ft=scheme
;;;;
;;;; A tool for performing Pomodoros.
;;;;

(import (scheme base)
        (scheme load)
        (scheme file)
        (scheme write)
        (scheme process-context)
        (chibi process)
        (chibi filesystem)
        (chibi pathname))

;;; Global data.

;;; Has this set been abandoned?
(define *pomo-set-abandon* #f)

;;; Times in minutes.
(define *work-time*       25)
(define *break-time*      5)
(define *long-break-time* 15)
(define *set-length*      4)

;;;;
;;;; Definitions for hooks, a list of thunks to execute at a certain time.
;;;;

;;; Add a thunk to a hook. 
(define-syntax add-hook!
  (syntax-rules ()
    ((add-hook! hook proc)
     (set! hook (cons proc hook)))))

;;; Call all the thunks registered to this hook.
(define (call-hooks hook)
  (for-each (lambda (p) (p)) hook))

(define-syntax define-hook
  (syntax-rules ()
    ((_ hook-name)
     (define hook-name '()))))

(define-hook *pomo-work-begin-hook*)
(define-hook *pomo-work-end-hook*)
(define-hook *pomo-break-begin-hook*)
(define-hook *pomo-break-end-hook*)
(define-hook *pomo-set-abandoned-hook*)
(define-hook *pomo-finished-hook*)

;;; Perform
(define (do-set work-time break-time)
  (call-hooks *pomo-work-begin-hook*)
  (sleep (* 60 work-time))
  (call-hooks *pomo-work-end-hook*)
  (call-hooks *pomo-break-begin-hook*)
  (sleep (* 60 break-time))
  (call-hooks *pomo-break-end-hook*))

(define (long-break time)
  (call-hooks *pomo-break-begin-hook*)
  (sleep (* 60 time))
  (call-hooks *pomo-break-end-hook*))

(define (pomodoro work-length break-length long-break-length set-count)
  (let set-loop ((current-set 1))
    (if (= current-set set-count)
      (long-break long-break-length)
      (begin 
       (do-set work-length break-length)
       (set-loop (+ current-set 1)))))
  (call-hooks *pomo-finished-hook*))


;;;; Filesystem status updater, allowing other programs to see the current
;;;; status of the pomodoro cycle by just checking if a file exists or not.

;;; Where the filesystem status will go.
(define *status-dir*
  (string-append (get-environment-variable "TMPDIR")
                 "/pomo"))

;;; Create a file at the given path.
(define (touch path)
  (close-output-port (open-output-file path)))

;;; While we are running, make sure a file exists that shows where we currently
;;; are in the pomodoro set.
(define (update-status working?)

  ;;; Move to the other file.
  (define (switch-file from-file to-file)
    (when (file-exists? from-file)
          (delete-file from-file))
    (touch to-file))

  (let ((working-file (string-append *status-dir* "/wrk"))
        (break-file (string-append *status-dir* "/brk")))
    (unless (file-directory? *status-dir*)
      (create-directory* *status-dir*))
    (if working?
        (switch-file break-file working-file)
        (switch-file working-file break-file))))

;;; Destroy all the files in the status file directory.
(define (clean-status)
  (delete-file-hierarchy *status-dir*))

;;;; Enable playing a clock ticking background noise to remind you that you are
;;;; in a pomodoro right now.

(define *tick-sound*
  (string-append (get-environment-variable "XDG_CONFIG_HOME")
                 "/pomo/ticking.mp3"))

(define tick-pid #f)

(define (start-ticking)
  (display *tick-sound*)
  (newline)
  (call-with-process-io `(mpv -really-quiet -loop ,0 ,*tick-sound*)
    (lambda (pid stdin stdout stderr)
      (set! tick-pid pid))))

(define (stop-ticking)
  (if tick-pid
    (kill tick-pid signal/kill)
    (error "can't stop ticking, no PID for ticking program found")))

;;;; Use libcanberra and libnotify to send notifications to the user 

(define (play-sound what)
  (system "canberra-gtk-play" "-i" (symbol->string what)))

(define (alert message)
  (system "notify-send" "--urgency=critical" "pomodoro" message))


(add-hook! *pomo-work-begin-hook*
            	   (lambda ()
            	     (play-sound 'bell)
            	     (alert "start working!")
            	     (update-status #t)
            	     (system "punch" "in")
            	     (start-ticking)))

(add-hook! *pomo-work-end-hook*
            	   (lambda ()
            	     (stop-ticking)
            	     (system "punch" "out")))

(add-hook! *pomo-break-begin-hook*
            	   (lambda ()
            	     (play-sound 'bell)
            	     (alert "break time!")
            	     (update-status #f)
            	     (system "punch" "in" "break")))

(add-hook! *pomo-break-end-hook*
            	   (lambda ()
            	     (system "punch" "out")))

(add-hook! *pomo-finished-hook*
           (lambda ()
             (play-sound 'complete)
             (alert "done!")
             (clean-status)))

;;;; Set up signal handling and plug in all the hooks for integration with the
;;;; rest of the OS.
(set-signal-action! signal/term 
  (lambda (signum)
    (stop-ticking)
    (clean-status)
    (set! *pomo-set-abandoned* #t)))

(pomodoro *work-time* *break-time* *long-break-time* *set-length*)

